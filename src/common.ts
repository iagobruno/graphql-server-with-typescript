import { PubSub, AuthenticationError } from 'apollo-server'
import * as jwt from 'jwt-simple'
import { isJWT } from 'validator'
import { addHours, getTime, differenceInHours } from 'date-fns'
import { GraphQLPageInfo, GraphQLNode, GraphQLMutationResponse } from './resolvers-types'
import { ScopesArray, checkIsAuthenticated } from './permissions'
import { users } from '../data'

/**
 * The shape of context object passed to all resolvers in api.
 */
export interface Context {
  user?: typeof users[0],
  jwtPayload?: JWTPayload,
}

/** @see https://www.apollographql.com/docs/apollo-server/features/subscriptions/ */
export const pubsub = new PubSub()
/**
 * List of events that are triggered by resolvers.
 */
export enum APIEvents {
  TWEET_ADDED = 'TWEET_ADDED',
  USER_ADDED = 'USER_ADDED',
}

/**
 * ! The jwt secret is here just to not complicate the codes. A good practice is store it in process.env.JWT_SECRET !
 * @see https://passwordsgenerator.net/
 */
const JWT_SECRET = 'X+T4Qa-kx-yG36Gz'
const maxJWTValidityHours = 24

/**
 * The payload shape of all tokens generated by the "createJWT" function.
 */
export type JWTPayload = {
  /** Id do usuÃ¡rio registrado no token. */
  subject: string,
  /** List of scopes this token has access to. */
  scopes: ScopesArray,
  /** JavaScript date timestamp. */
  issuedAt: number,
  /** JavaScript date timestamp. */
  expiresIn: number,
  /** Address of the route that generated the token. */
  issuer?: string,
}

/**
 * Create a JSON Web Token (JWT) so that the "verifyJWT" function can securely verify
 * which user is trying to access the api.
 * @see https://jwt.io/
 *
 * @param subject Id of the user who generated the token.
 * @param issuer Address of the route that generated the token.
 */
export async function createJWT(subject: string, issuer?: string) {
  const expiresIn = addHours(Date.now(), maxJWTValidityHours)
  const payload: JWTPayload = {
    subject,
    scopes: ['tweets', 'users'],
    issuedAt: Date.now(),
    expiresIn: getTime(expiresIn),
    issuer,
  }

  return {
    token: jwt.encode(payload, JWT_SECRET),
    expiresIn
  };
}

/**
 * Verify that the request contains a valid JWT token created by the "createJWT" function.
 * @see https://jwt.io/
 *
 * @param isRequired If false, the request will be accepted even if a token is not found. Default = true
 * @throws Throws an error if a problem occurs while validating the token.
 * @returns Returns the payload of token if all goes well or returns null if no token is found.
 */
export async function verifyJWT(authorizationToken: string, isRequired = true) {
  // Check if there is a token in the request
  if (!authorizationToken || authorizationToken.trim() === '') {
    // Allow access if authentication is optional, otherwise block request
    if (isRequired === false) return null;
    else throw new AuthenticationError('Token jwt not found.');
  }

  // Verify if token is well formatted ("Bearer 1234.5678.91011")
  const [scheme, token] = authorizationToken.split(' ')
  if (
    typeof scheme === 'undefined' ||
    scheme !== 'Bearer' ||
    typeof token === 'undefined' ||
    token.trim() === '' ||
    !isJWT(token)
  ) {
    throw new AuthenticationError('Jwt token is in an invalid format.');
  }

  // Attempt to validate received token
  let payload: JWTPayload
  try {
    payload = jwt.decode(token, JWT_SECRET)
  }
  catch(err) {
    // console.log('jwt.decode error:', err)
    throw new AuthenticationError('Unable to validate received jwt token.');
  }

  // Check if the token has expired
  if (differenceInHours(Date.now(), payload.issuedAt) > maxJWTValidityHours) {
    throw new AuthenticationError('Token jwt has expired.');
  }

  // Allow access!
  return payload;
}

/**
 * Function to be used within resolvers to get informations of logged in user.
 * @throws Throws an error if no users are found.
 * @returns Returns an object with user infos.
 *
 * @example
 * async resolver(_, args, context) {
 *   await checkIsAuthenticated(context)
 *   const currentUser = await getLoggedUser(context)
 *   ...
 * }
 */
export async function getLoggedUser(context: Context) {
  await checkIsAuthenticated(context)

  return context.user!;
}

export function findUserById(id: string) {
  return users.find(user => user.id === id);
}

type PaginatedResponseArgs<Node> = {
  allNodes: Node[],
  nodes: Node[],
  firstArg: number,
  startIndex: number,
}

/**
 * @returns An object with the default shape of GraphQL paginations.
 */
export function generatePaginatedConnection<NodeType extends GraphQLNode>({ allNodes, nodes, firstArg, startIndex }: PaginatedResponseArgs<NodeType>) {
  const hasAtLeast1Item = (nodes.length >= 1)
  const pageInfo: GraphQLPageInfo = {
    size: Math.min(firstArg, nodes.length),
    startCursor: hasAtLeast1Item ? nodes[0].id : null,
    endCursor: hasAtLeast1Item ? nodes[nodes.length-1].id : null,
    hasPreviousPage: startIndex > 0,
    hasNextPage: (startIndex + firstArg) < allNodes.length,
  }

  return {
    nodes,
    pageInfo,
    totalCount: allNodes.length
  };
}

interface ResponseShape extends GraphQLMutationResponse {
  success: boolean,
  message: string,
  node?: any,
}
/**
 * Force resolver to return a response with a default format to the client.
 */
export function defaultResponseShape<R extends ResponseShape>(response: R): R {
  return response;
}
